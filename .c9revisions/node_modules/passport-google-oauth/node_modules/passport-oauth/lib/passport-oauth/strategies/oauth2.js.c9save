{"ts":1361604992905,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Module dependencies.\n */\nvar passport = require('passport')\n  , url = require('url')\n  , util = require('util')\n  , utils = require('./utils')\n  , OAuth2 = require('oauth').OAuth2\n  , InternalOAuthError = require('../errors/internaloautherror');\n\n\n/**\n * `OAuth2Strategy` constructor.\n *\n * The OAuth 2.0 authentication strategy authenticates requests using the OAuth\n * 2.0 protocol.\n *\n * OAuth 2.0 provides a facility for delegated authentication, whereby users can\n * authenticate using a third-party service such as Facebook.  Delegating in\n * this manner involves a sequence of events, including redirecting the user to\n * the third-party service for authorization.  Once authorization has been\n * granted, the user is redirected back to the application and an authorization\n * code can be used to obtain credentials.\n *\n * Applications must supply a `verify` callback which accepts an `accessToken`,\n * `refreshToken` and service-specific `profile`, and then calls the `done`\n * callback supplying a `user`, which should be set to `false` if the\n * credentials are not valid.  If an exception occured, `err` should be set.\n *\n * Options:\n *   - `authorizationURL`  URL used to obtain an authorization grant\n *   - `tokenURL`          URL used to obtain an access token\n *   - `clientID`          identifies client to service provider\n *   - `clientSecret`      secret used to establish ownership of the client identifer\n *   - `callbackURL`       URL to which the service provider will redirect the user after obtaining authorization\n *   - `passReqToCallback` when `true`, `req` is the first argument to the verify callback (default: `false`)\n *\n * Examples:\n *\n *     passport.use(new OAuth2Strategy({\n *         authorizationURL: 'https://www.example.com/oauth2/authorize',\n *         tokenURL: 'https://www.example.com/oauth2/token',\n *         clientID: '123-456-789',\n *         clientSecret: 'shhh-its-a-secret'\n *         callbackURL: 'https://www.example.net/auth/example/callback'\n *       },\n *       function(accessToken, refreshToken, profile, done) {\n *         User.findOrCreate(..., function (err, user) {\n *           done(err, user);\n *         });\n *       }\n *     ));\n *\n * @param {Object} options\n * @param {Function} verify\n * @api public\n */\nfunction OAuth2Strategy(options, verify) {\n  options = options || {}\n  passport.Strategy.call(this);\n  this.name = 'oauth2';\n  this._verify = verify;\n  \n  if (!options.authorizationURL) throw new Error('OAuth2Strategy requires a authorizationURL option');\n  if (!options.tokenURL) throw new Error('OAuthStrategy requires a tokenURL option');\n  if (!options.clientID) throw new Error('OAuth2Strategy requires a clientID option');\n  if (!options.clientSecret) throw new Error('OAuth2Strategy requires a clientSecret option');\n\n  // NOTE: The _oauth2 property is considered \"protected\".  Subclasses are\n  //       allowed to use it when making protected resource requests to retrieve\n  //       the user profile.\n  this._oauth2 = new OAuth2(options.clientID,  options.clientSecret,\n      '', options.authorizationURL, options.tokenURL, options.customHeaders);\n\n  this._callbackURL = options.callbackURL;\n  this._scope = options.scope;\n  this._scopeSeparator = options.scopeSeparator || ' ';\n  this._passReqToCallback = options.passReqToCallback;\n  this._skipUserProfile = (options.skipUserProfile === undefined) ? false : options.skipUserProfile;\n}\n\n/**\n * Inherit from `passport.Strategy`.\n */\nutil.inherits(OAuth2Strategy, passport.Strategy);\n\n\n/**\n * Authenticate request by delegating to a service provider using OAuth 2.0.\n *\n * @param {Object} req\n * @api protected\n */\nOAuth2Strategy.prototype.authenticate = function(req, options) {\n  options = options || {};\n  var self = this;\n  \n  if (req.query && req.query.error) {\n    // TODO: Error information pertaining to OAuth 2.0 flows is encoded in the\n    //       query parameters, and should be propagated to the application.\n    return this.fail();\n  }\n  \n  var callbackURL = options.callbackURL || this._callbackURL;\n  if (callbackURL) {\n    var parsed = url.parse(callbackURL);\n    if (!parsed.protocol) {\n      // The callback URL is relative, resolve a fully qualified URL from the\n      // URL of the originating request.\n      callbackURL = url.resolve(utils.originalURL(req), callbackURL);\n    }\n  }\n  \n  if (req.query && req.query.code) {\n    var code = req.query.code;\n    \n    // NOTE: The module oauth (0.9.5), which is a dependency, automatically adds\n    //       a 'type=web_server' parameter to the percent-encoded data sent in\n    //       the body of the access token request.  This appears to be an\n    //       artifact from an earlier draft of OAuth 2.0 (draft 22, as of the\n    //       time of this writing).  This parameter is not necessary, but its\n    //       presence does not appear to cause any issues.\n    this._oauth2.getOAuthAccessToken(code, { grant_type: 'authorization_code', redirect_uri: callbackURL },\n      function(err, accessToken, refreshToken, params) {\n        if (err) { return self.error(new InternalOAuthError('failed to obtain access token', err)); }\n        \n        self._loadUserProfile(accessToken, function(err, profile) {\n          if (err) { return self.error(err); };\n          \n          function verified(err, user, info) {\n            if (err) { return self.error(err); }\n            if (!user) { return self.fail(info); }\n            self.success(user, info);\n          }\n          \n          if (self._passReqToCallback) {\n            var arity = self._verify.length;\n            if (arity == 6) {\n              self._verify(req, accessToken, refreshToken, params, profile, verified);\n            } else { // arity == 5\n              self._verify(req, accessToken, refreshToken, profile, verified);\n            }\n          } else {\n            var arity = self._verify.length;\n            if (arity == 5) {\n              self._verify(accessToken, refreshToken, params, profile, verified);\n            } else { // arity == 4\n              self._verify(accessToken, refreshToken, profile, verified);\n            }\n          }\n        });\n      }\n    );\n  } else {\n    // NOTE: The module oauth (0.9.5), which is a dependency, automatically adds\n    //       a 'type=web_server' parameter to the query portion of the URL.\n    //       This appears to be an artifact from an earlier draft of OAuth 2.0\n    //       (draft 22, as of the time of this writing).  This parameter is not\n    //       necessary, but its presence does not appear to cause any issues.\n    \n    var params = this.authorizationParams(options);\n    params['response_type'] = 'code';\n    params['redirect_uri'] = callbackURL;\n    var scope = options.scope || this._scope;\n    if (scope) {\n      if (Array.isArray(scope)) { scope = scope.join(this._scopeSeparator); }\n      params.scope = scope;\n    }\n    var state = options.state;\n    if (state) { params.state = state; }\n    \n    var location = this._oauth2.getAuthorizeUrl(params);\n    this.redirect(location);\n  }\n}\n\n/**\n * Retrieve user profile from service provider.\n *\n * OAuth 2.0-based authentication strategies can overrride this function in\n * order to load the user's profile from the service provider.  This assists\n * applications (and users of those applications) in the initial registration\n * process by automatically submitting required information.\n *\n * @param {String} accessToken\n * @param {Function} done\n * @api protected\n */\nOAuth2Strategy.prototype.userProfile = function(accessToken, done) {\n  return done(null, {});\n}\n\n/**\n * Return extra parameters to be included in the authorization request.\n *\n * Some OAuth 2.0 providers allow additional, non-standard parameters to be\n * included when requesting authorization.  Since these parameters are not\n * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication\n * strategies can overrride this function in order to populate these parameters\n * as required by the provider.\n *\n * @param {Object} options\n * @return {Object}\n * @api protected\n */\nOAuth2Strategy.prototype.authorizationParams = function(options) {\n  return {};\n}\n\n/**\n * Load user profile, contingent upon options.\n *\n * @param {String} accessToken\n * @param {Function} done\n * @api private\n */\nOAuth2Strategy.prototype._loadUserProfile = function(accessToken, done) {\n  var self = this;\n  \n  function loadIt() {\n    return self.userProfile(accessToken, done);\n  }\n  function skipIt() {\n    return done(null);\n  }\n  \n  if (typeof this._skipUserProfile == 'function' && this._skipUserProfile.length > 1) {\n    // async\n    this._skipUserProfile(accessToken, function(err, skip) {\n      if (err) { return done(err); }\n      if (!skip) { return loadIt(); }\n      return skipIt();\n    });\n  } else {\n    var skip = (typeof this._skipUserProfile == 'function') ? this._skipUserProfile() : this._skipUserProfile;\n    if (!skip) { return loadIt(); }\n    return skipIt();\n  }\n}\n\n\n/**\n * Expose `OAuth2Strategy`.\n */ \nmodule.exports = OAuth2Strategy;\n\n"]],"start1":0,"start2":0,"length1":0,"length2":9015}]],"length":9015}
