{"ts":1366690557968,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*global jQuery:false, alert:false */\n\n/*\n * Default text - jQuery plugin for html5 dragging files from desktop to browser\n *\n * Author: Weixi Yen\n *\n * Email: [Firstname][Lastname]@gmail.com\n *\n * Copyright (c) 2010 Resopollution\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * Project home:\n *   http://www.github.com/weixiyen/jquery-filedrop\n *\n * Version:  0.1.0\n *\n * Features:\n *      Allows sending of extra parameters with file.\n *      Works with Firefox 3.6+\n *      Future-compliant with HTML5 spec (will work with Webkit browsers and IE9)\n * Usage:\n *  See README at project homepage\n *\n */\n;(function($) {\n\n  jQuery.event.props.push(\"dataTransfer\");\n\n  var default_opts = {\n      fallback_id: '',\n      url: '',\n      refresh: 1000,\n      paramname: 'userfile',\n      allowedfiletypes:[],\n      maxfiles: 25,           // Ignored if queuefiles is set > 0\n      maxfilesize: 10,         // MB file size limit\n      queuefiles: 0,          // Max files before queueing (for large volume uploads)\n      queuewait: 200,         // Queue wait time if full\n      data: {},\n      headers: {},\n      drop: empty,\n      dragStart: empty,\n      dragEnter: empty,\n      dragOver: empty,\n      dragLeave: empty,\n      docEnter: empty,\n      docOver: empty,\n      docLeave: empty,\n      beforeEach: empty,\n      afterAll: empty,\n      rename: empty,\n      error: function(err, file, i) {\n        alert(err);\n      },\n      uploadStarted: empty,\n      uploadFinished: empty,\n      progressUpdated: empty,\n      globalProgressUpdated: empty,\n      speedUpdated: empty\n      },\n      errors = [\"BrowserNotSupported\", \"TooManyFiles\", \"FileTooLarge\", \"FileTypeNotAllowed\"],\n      doc_leave_timer, stop_loop = false,\n      files_count = 0,\n      files;\n\n  $.fn.filedrop = function(options) {\n    var opts = $.extend({}, default_opts, options),\n        global_progress = [];\n\n    this.on('drop', drop).on('dragstart', opts.dragStart).on('dragenter', dragEnter).on('dragover', dragOver).on('dragleave', dragLeave);\n    $(document).on('drop', docDrop).on('dragenter', docEnter).on('dragover', docOver).on('dragleave', docLeave);\n\n    $('#' + opts.fallback_id).change(function(e) {\n      opts.drop(e);\n      files = e.target.files;\n      files_count = files.length;\n      upload();\n    });\n\n    function drop(e) {\n      opts.drop.call(this, e);\n      files = e.dataTransfer.files;\n      if (files === null || files === undefined || files.length === 0) {\n        opts.error(errors[0]);\n        return false;\n      }\n      files_count = files.length;\n      upload();\n      e.preventDefault();\n      return false;\n    }\n\n    function getBuilder(filename, filedata, mime, boundary) {\n      var dashdash = '--',\n          crlf = '\\r\\n',\n          builder = '';\n\n      if (opts.data) {\n        var params = $.param(opts.data).split(/&/);\n\n        $.each(params, function() {\n          var pair = this.split(\"=\", 2),\n              name = decodeURIComponent(pair[0]),\n              val  = decodeURIComponent(pair[1]);\n\n          builder += dashdash;\n          builder += boundary;\n          builder += crlf;\n          builder += 'Content-Disposition: form-data; name=\"' + name + '\"';\n          builder += crlf;\n          builder += crlf;\n          builder += val;\n          builder += crlf;\n        });\n      }\n\n      builder += dashdash;\n      builder += boundary;\n      builder += crlf;\n      builder += 'Content-Disposition: form-data; name=\"' + opts.paramname + '\"';\n      builder += '; filename=\"' + filename + '\"';\n      builder += crlf;\n\n      builder += 'Content-Type: ' + mime;\n      builder += crlf;\n      builder += crlf;\n\n      builder += filedata;\n      builder += crlf;\n\n      builder += dashdash;\n      builder += boundary;\n      builder += dashdash;\n      builder += crlf;\n      return builder;\n    }\n\n    function progress(e) {\n      if (e.lengthComputable) {\n        var percentage = Math.round((e.loaded * 100) / e.total);\n        if (this.currentProgress !== percentage) {\n\n          this.currentProgress = percentage;\n          opts.progressUpdated(this.index, this.file, this.currentProgress);\n\n          global_progress[this.global_progress_index] = this.currentProgress;\n          globalProgress();\n\n          var elapsed = new Date().getTime();\n          var diffTime = elapsed - this.currentStart;\n          if (diffTime >= opts.refresh) {\n            var diffData = e.loaded - this.startData;\n            var speed = diffData / diffTime; // KB per second\n            opts.speedUpdated(this.index, this.file, speed);\n            this.startData = e.loaded;\n            this.currentStart = elapsed;\n          }\n        }\n      }\n    }\n\n    function globalProgress() {\n      if (global_progress.length === 0) {\n        return;\n      }\n\n      var total = 0, index;\n      for (index in global_progress) {\n        if(global_progress.hasOwnProperty(index)) {\n          total = total + global_progress[index];\n        }\n      }\n\n      opts.globalProgressUpdated(Math.round(total / global_progress.length));\n    }\n\n    // Respond to an upload\n    function upload() {\n      stop_loop = false;\n\n      if (!files) {\n        opts.error(errors[0]);\n        return false;\n      }\n\n      if (opts.allowedfiletypes.push && opts.allowedfiletypes.length) {\n        for(var fileIndex = files.length;fileIndex--;) {\n          if(!files[fileIndex].type || $.inArray(files[fileIndex].type, opts.allowedfiletypes) < 0) {\n            opts.error(errors[3], files[fileIndex]);\n            return false;\n          }\n        }\n      }\n\n      var filesDone = 0,\n          filesRejected = 0;\n\n      if (files_count > opts.maxfiles && opts.queuefiles === 0) {\n        opts.error(errors[1]);\n        return false;\n      }\n\n      // Define queues to manage upload process\n      var workQueue = [];\n      var processingQueue = [];\n      var doneQueue = [];\n\n      // Add everything to the workQueue\n      for (var i = 0; i < files_count; i++) {\n        workQueue.push(i);\n      }\n\n      // Helper function to enable pause of processing to wait\n      // for in process queue to complete\n      var pause = function(timeout) {\n        setTimeout(process, timeout);\n        return;\n      };\n\n      // Process an upload, recursive\n      var process = function() {\n\n        var fileIndex;\n\n        if (stop_loop) {\n          return false;\n        }\n\n        // Check to see if are in queue mode\n        if (opts.queuefiles > 0 && processingQueue.length >= opts.queuefiles) {\n          return pause(opts.queuewait);\n        } else {\n          // Take first thing off work queue\n          fileIndex = workQueue[0];\n          workQueue.splice(0, 1);\n\n          // Add to processing queue\n          processingQueue.push(fileIndex);\n        }\n\n        try {\n          if (beforeEach(files[fileIndex]) !== false) {\n            if (fileIndex === files_count) {\n              return;\n            }\n            var reader = new FileReader(),\n                max_file_size = 1048576 * opts.maxfilesize;\n\n            reader.index = fileIndex;\n            if (files[fileIndex].size > max_file_size) {\n              opts.error(errors[2], files[fileIndex], fileIndex);\n              // Remove from queue\n              processingQueue.forEach(function(value, key) {\n                if (value === fileIndex) {\n                  processingQueue.splice(key, 1);\n                }\n              });\n              filesRejected++;\n              return true;\n            }\n\n            reader.onloadend = !opts.beforeSend ? send : function (e) {\n              opts.beforeSend(files[fileIndex], fileIndex, function () { send(e); });\n            };\n\n            reader.readAsBinaryString(files[fileIndex]);\n\n          } else {\n            filesRejected++;\n          }\n        } catch (err) {\n          // Remove from queue\n          processingQueue.forEach(function(value, key) {\n            if (value === fileIndex) {\n              processingQueue.splice(key, 1);\n            }\n          });\n          opts.error(errors[0]);\n          return false;\n        }\n\n        // If we still have work to do,\n        if (workQueue.length > 0) {\n          process();\n        }\n      };\n\n      var send = function(e) {\n\n        var fileIndex = ((typeof(e.srcElement) === \"undefined\") ? e.target : e.srcElement).index;\n\n        // Sometimes the index is not attached to the\n        // event object. Find it by size. Hack for sure.\n        if (e.target.index === undefined) {\n          e.target.index = getIndexBySize(e.total);\n        }\n\n        var xhr = new XMLHttpRequest(),\n            upload = xhr.upload,\n            file = files[e.target.index],\n            index = e.target.index,\n            start_time = new Date().getTime(),\n            boundary = '------multipartformboundary' + (new Date()).getTime(),\n            global_progress_index = global_progress.length,\n            builder,\n            newName = rename(file.name),\n            mime = file.type;\n\n        if (opts.withCredentials) {\n          xhr.withCredentials = opts.withCredentials;\n        }\n\n        if (typeof newName === \"string\") {\n          builder = getBuilder(newName, e.target.result, mime, boundary);\n        } else {\n          builder = getBuilder(file.name, e.target.result, mime, boundary);\n        }\n\n        upload.index = index;\n        upload.file = file;\n        upload.downloadStartTime = start_time;\n        upload.currentStart = start_time;\n        upload.currentProgress = 0;\n        upload.global_progress_index = global_progress_index;\n        upload.startData = 0;\n        upload.addEventListener(\"progress\", progress, false);\n\n        xhr.open(\"POST\", opts.url, true);\n        xhr.setRequestHeader('content-type', 'multipart/form-data; boundary=' + boundary);\n\n        // Add headers\n        $.each(opts.headers, function(k, v) {\n          xhr.setRequestHeader(k, v);\n        });\n\n        xhr.sendAsBinary(builder);\n\n        global_progress[global_progress_index] = 0;\n        globalProgress();\n\n        opts.uploadStarted(index, file, files_count);\n\n        xhr.onload = function() {\n            var serverResponse = null;\n\n            if (xhr.responseText) {\n              try {\n                serverResponse = jQuery.parseJSON(xhr.responseText);\n              }\n              catch (e) {\n                serverResponse = xhr.responseText;\n              }\n            }\n\n            var now = new Date().getTime(),\n                timeDiff = now - start_time,\n                result = opts.uploadFinished(index, file, serverResponse, timeDiff, xhr);\n            filesDone++;\n\n            // Remove from processing queue\n            processingQueue.forEach(function(value, key) {\n              if (value === fileIndex) {\n                processingQueue.splice(key, 1);\n              }\n            });\n\n            // Add to donequeue\n            doneQueue.push(fileIndex);\n\n            // Make sure the global progress is updated\n            global_progress[global_progress_index] = 100;\n            globalProgress();\n\n            if (filesDone === (files_count - filesRejected)) {\n              afterAll();\n            }\n            if (result === false) {\n              stop_loop = true;\n            }\n          \n\n          // Pass any errors to the error option\n          if (xhr.status < 200 && xhr.status > 299) {\n            opts.error(xhr.statusText);\n          }\n        };\n      };\n\n      // Initiate the processing loop\n      process();\n    }\n\n    function getIndexBySize(size) {\n      for (var i = 0; i < files_count; i++) {\n        if (files[i].size === size) {\n          return i;\n        }\n      }\n\n      return undefined;\n    }\n\n    function rename(name) {\n      return opts.rename(name);\n    }\n\n    function beforeEach(file) {\n      return opts.beforeEach(file);\n    }\n\n    function afterAll() {\n      return opts.afterAll();\n    }\n\n    function dragEnter(e) {\n      clearTimeout(doc_leave_timer);\n      e.preventDefault();\n      opts.dragEnter.call(this, e);\n    }\n\n    function dragOver(e) {\n      clearTimeout(doc_leave_timer);\n      e.preventDefault();\n      opts.docOver.call(this, e);\n      opts.dragOver.call(this, e);\n    }\n\n    function dragLeave(e) {\n      clearTimeout(doc_leave_timer);\n      opts.dragLeave.call(this, e);\n      e.stopPropagation();\n    }\n\n    function docDrop(e) {\n      e.preventDefault();\n      opts.docLeave.call(this, e);\n      return false;\n    }\n\n    function docEnter(e) {\n      clearTimeout(doc_leave_timer);\n      e.preventDefault();\n      opts.docEnter.call(this, e);\n      return false;\n    }\n\n    function docOver(e) {\n      clearTimeout(doc_leave_timer);\n      e.preventDefault();\n      opts.docOver.call(this, e);\n      return false;\n    }\n\n    function docLeave(e) {\n      doc_leave_timer = setTimeout((function(_this) {\n        return function() {\n          opts.docLeave.call(_this, e);\n        };\n      })(this), 200);\n    }\n\n    return this;\n  };\n\n  function empty() {}\n\n  try {\n    if (XMLHttpRequest.prototype.sendAsBinary) {\n        return;\n    }\n    XMLHttpRequest.prototype.sendAsBinary = function(datastr) {\n      function byteValue(x) {\n        return x.charCodeAt(0) & 0xff;\n      }\n      var ords = Array.prototype.map.call(datastr, byteValue);\n      var ui8a = new Uint8Array(ords);\n      this.send(ui8a.buffer);\n    };\n  } catch (e) {}\n\n})(jQuery);\n"]],"start1":0,"start2":0,"length1":0,"length2":13312}]],"length":13312}
{"contributors":[],"silentsave":false,"ts":1366691863192,"patch":[[{"diffs":[[0,"ui8a"],[-1,".buffer"],[0,");\n "]],"start1":13261,"start2":13261,"length1":15,"length2":8}]],"length":13305,"saved":false}
